/*
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.0 of the PHP license,       |
   | that is bundled with this package in the file LICENSE, and is        |
   | available through the world-wide-web at the following url:           |
   | http://www.php.net/license/3_0.txt.                                  |
   | If you did not receive a copy of the PHP license and are unable to   |
   | obtain it through the world-wide-web, please send a note to          |
   | license@php.net so we can mail you a copy immediately.               |
   +----------------------------------------------------------------------+
   | Authors: Hartmut Holzgraefe <hartmut@php.net>                        |
   +----------------------------------------------------------------------+
*/

/* $ Id: $ */ 

// {{{ CREATE and DROP statements for this UDF

/*
register the functions provided by this UDF module using
CREATE FUNCTION regex_like RETURNS INTEGER SONAME "regex.so";
CREATE FUNCTION regex_substr RETURNS STRING SONAME "regex.so";
CREATE FUNCTION regex_instr RETURNS INTEGER SONAME "regex.so";
CREATE FUNCTION regex_replace RETURNS STRING SONAME "regex.so";

unregister the functions provided by this UDF module using
DROP FUNCTION regex_like;
DROP FUNCTION regex_substr;
DROP FUNCTION regex_instr;
DROP FUNCTION regex_replace;
*/
// }}}

// {{{ standard header stuff
#ifdef STANDARD
#include <stdio.h>
#include <string.h>
#ifdef __WIN__
typedef unsigned __int64 ulonglong; /* Microsofts 64 bit types */
typedef __int64 longlong;
#else
typedef unsigned long long ulonglong;
typedef long long longlong;
#endif /*__WIN__*/
#else
#include <my_global.h>
#include <my_sys.h>
#endif
#include <mysql.h>
#include <m_ctype.h>
#include <m_string.h>       // To get strmov()

// }}}

#ifdef HAVE_DLOPEN

#include "udf_regex.h"

// {{{ user defined header code

	#if MYSQL_VERSION_ID < 50000
	#error need MySQL >= 5.0
	#endif
	
	#include <sys/types.h>
	
	// TODO: my_regex.h is not installed by "make install"
	#include "/home/hartmut/projects/mysql/dev/5.0/regex/my_regex.h"
	
	// helper function borrowed from PHP, slightly modified
	char *my_regex_replace(const char *pattern, const char *replace, const char *string)
	{
		my_regex_t re;
		my_regmatch_t *subs;
	
		char *buf,  /* buf is where we build the replaced string */
			 *nbuf, /* nbuf is used when we grow the buffer */
			 *walkbuf; /* used to walk buf when replacing backrefs */
		const char *walk; /* used to walk replacement string for backrefs */
		int buf_len;
		int pos, tmp, string_len, new_l;
		int err, copts = REG_EXTENDED;
	
		string_len = strlen(string);
	
		err = my_regcomp(&re, pattern, copts, &my_charset_bin);
		if (err) {
			return NULL;
		}
	
		/* allocate storage for (sub-)expression-matches */
		subs = (my_regmatch_t *)calloc(sizeof(my_regmatch_t),re.re_nsub+1);
	
		/* start with a buffer that is twice the size of the stringo
		   we're doing replacements in */
		buf_len = 2 * string_len + 1;
		buf = calloc(buf_len, sizeof(char));
	
		err = pos = 0;
		buf[0] = '\0';
		while (!err) {
			err = my_regexec(&re, &string[pos], re.re_nsub+1, subs, (pos ? REG_NOTBOL : 0));
	
			if (err && err != REG_NOMATCH) {
				free(subs);
				free(buf);
				my_regfree(&re);
				return NULL;
			}
	
			if (!err) {
				/* backref replacement is done in two passes:
				   1) find out how long the string will be, and allocate buf
				   2) copy the part before match, replacement and backrefs to buf
	
				   Jaakko Hyv√§tti <Jaakko.Hyvatti@iki.fi>
				   */
	
				new_l = strlen(buf) + subs[0].rm_so; /* part before the match */
				walk = replace;
				while (*walk) {
					if ('\\' == *walk && isdigit((unsigned char)walk[1]) && ((unsigned char)walk[1]) - '0' <= re.re_nsub) {
						if (subs[walk[1] - '0'].rm_so > -1 && subs[walk[1] - '0'].rm_eo > -1) {
							new_l += subs[walk[1] - '0'].rm_eo - subs[walk[1] - '0'].rm_so;
						}    
						walk += 2;
					} else {
						new_l++;
						walk++;
					}
				}
				if (new_l + 1 > buf_len) {
					buf_len = 1 + buf_len + 2 * new_l;
					nbuf = malloc(buf_len);
					strcpy(nbuf, buf);
					free(buf);
					buf = nbuf;
				}
				tmp = strlen(buf);
				/* copy the part of the string before the match */
				strncat(buf, &string[pos], subs[0].rm_so);
	
				/* copy replacement and backrefs */
				walkbuf = &buf[tmp + subs[0].rm_so];
				walk = replace;
				while (*walk) {
					if ('\\' == *walk && isdigit(walk[1]) && walk[1] - '0' <= (int)re.re_nsub) {
						if (subs[walk[1] - '0'].rm_so > -1 && subs[walk[1] - '0'].rm_eo > -1
							/* this next case shouldn't happen. it does. */
							&& subs[walk[1] - '0'].rm_so <= subs[walk[1] - '0'].rm_eo) {
							
							tmp = subs[walk[1] - '0'].rm_eo - subs[walk[1] - '0'].rm_so;
							memcpy (walkbuf, &string[pos + subs[walk[1] - '0'].rm_so], tmp);
							walkbuf += tmp;
						}
						walk += 2;
					} else {
						*walkbuf++ = *walk++;
					}
				}
				*walkbuf = '\0';
	
				/* and get ready to keep looking for replacements */
				if (subs[0].rm_so == subs[0].rm_eo) {
					if (subs[0].rm_so + pos >= string_len) {
						break;
					}
					new_l = strlen (buf) + 1;
					if (new_l + 1 > buf_len) {
						buf_len = 1 + buf_len + 2 * new_l;
						nbuf = calloc(buf_len, sizeof(char));
						strcpy(nbuf, buf);
						free(buf);
						buf = nbuf;
					}
					pos += subs[0].rm_eo + 1;
					buf [new_l-1] = string [pos-1];
					buf [new_l] = '\0';
				} else {
					pos += subs[0].rm_eo;
				}
			} else { /* REG_NOMATCH */
				new_l = strlen(buf) + strlen(&string[pos]);
				if (new_l + 1 > buf_len) {
					buf_len = new_l + 1; /* now we know exactly how long it is */
					nbuf = calloc(buf_len, sizeof(char));
					strcpy(nbuf, buf);
					free(buf);
					buf = nbuf;
				}
				/* stick that last bit of string on our output */
				strcat(buf, &string[pos]);
			}
		}
	
		/* don't want to leak memory .. */
		free(subs);
		my_regfree(&re);
	
		/* whew. */
		return (buf);
	}
// }}} 

// {{{ prototypes

#ifdef  __cplusplus
extern "C" {
#endif
/* FUNCTION regex_like */
my_bool regex_like_init(UDF_INIT *initid, UDF_ARGS *args, char *message);
long long regex_like(UDF_INIT *initid, UDF_ARGS *args, char *is_null, char *error);
void regex_like_deinit(UDF_INIT *initid);

/* FUNCTION regex_substr */
my_bool regex_substr_init(UDF_INIT *initid, UDF_ARGS *args, char *message);
char * regex_substr(UDF_INIT *initid, UDF_ARGS *args, char *result, unsigned long *length, char *is_null, char *error);
void regex_substr_deinit(UDF_INIT *initid);

/* FUNCTION regex_instr */
my_bool regex_instr_init(UDF_INIT *initid, UDF_ARGS *args, char *message);
long long regex_instr(UDF_INIT *initid, UDF_ARGS *args, char *is_null, char *error);
void regex_instr_deinit(UDF_INIT *initid);

/* FUNCTION regex_replace */
my_bool regex_replace_init(UDF_INIT *initid, UDF_ARGS *args, char *message);
char * regex_replace(UDF_INIT *initid, UDF_ARGS *args, char *result, unsigned long *length, char *is_null, char *error);
void regex_replace_deinit(UDF_INIT *initid);

#ifdef  __cplusplus
}
#endif
// }}}

// {{{ UDF functions

// {{{ FUNCTION regex_like RETURNS INTEGER
struct regex_like_t {
  my_regex_t expr;
  int dynamic;
};

/* regex_like init function */
my_bool regex_like_init(UDF_INIT *initid, UDF_ARGS *args, char *message)
{
	DBUG_ENTER("regex::regex_like_init");
	struct regex_like_t *data = (struct regex_like_t *)calloc(sizeof(struct regex_like_t), 1);

	char *text = NULL;
	long long text_len = 0;
	char *pattern = NULL;
	long long pattern_len = 0;

	text = (char *)args->args[0];
	text_len = args->lengths[0];
	pattern = (char *)args->args[1];
	pattern_len = args->lengths[1];
	if (!data) {
		strcpy(message, "out of memory in regex_like()");
		DBUG_RETURN(1);
	}

	initid->ptr = (char *)data;

	initid->maybe_null = 1;

	if (args->arg_count != 2) {
		strcpy(message,"wrong number of parameters for regex_like()");
		DBUG_RETURN(1);
	}
	args->arg_type[0] = STRING_RESULT;
	args->arg_type[1] = STRING_RESULT;

	do {
		if (pattern) {
				// static regex pattern -> we can compile it once and reuse it 
				int stat;
				char *copy;
		
				// we have to make sure we have a NUL terminated C string
				// as argument for my_regcomp           
				copy = strndup(pattern, pattern_len);
				stat  = my_regcomp(&data->expr, copy, REG_EXTENDED, &my_charset_bin);
				free(copy);
		
				if (stat) {
					sprintf(message, "regcomp failed (error: %d)", stat);
					return 1; 
				}
		
				data->dynamic = 0;
			} else {
				data->dynamic = 1;
			}
	} while (0);

	DBUG_RETURN(0);
}

/* regex_like deinit function */
void regex_like_deinit(UDF_INIT *initid)
{
	DBUG_ENTER("regex::regex_like_deinit");
	struct regex_like_t *data = (struct regex_like_t *)(initid->ptr);

	if (!data->dynamic) {
			// free static compiler pattern
			my_regfree(&data->expr);
		}

	if (initid->ptr) {
		free(initid->ptr);
	}
	DBUG_VOID_RETURN;
}

/* regex_like actual processing function */
long long regex_like(UDF_INIT *initid, UDF_ARGS *args, char *is_null, char *error)
{
	DBUG_ENTER("regex::regex_like");
	struct regex_like_t *data = (struct regex_like_t *)initid->ptr;

	char *text = NULL;
	long long text_len = 0;
	char *pattern = NULL;
	long long pattern_len = 0;

	text = (char *)args->args[0];
	text_len = args->lengths[0];
	pattern = (char *)args->args[1];
	pattern_len = args->lengths[1];
	do {
		my_regmatch_t match;
			int stat;
			char *copy;
			
			if (data->dynamic) {
				copy = strndup(pattern, pattern_len);
				stat  = my_regcomp(&data->expr, copy, REG_EXTENDED, &my_charset_bin);
				free(copy);
				if (stat) {
					// TODO: need ERROR() and WARNING() macro
					RETURN_NULL;
				}
			}
		
			copy = strndup(text, text_len);
			stat = my_regexec(&data->expr, text, 1, &match, 0);
			free(copy);
		
			if (data->dynamic) {
				my_regfree(&data->expr);
			}
		
			if (stat && (stat != REG_NOMATCH)) {
				fprintf(stderr, "regexec error %d '%s' '%s'\n", stat, pattern, text);
				RETURN_NULL;
			}
		
			RETURN_LONGLONG(stat == REG_NOMATCH ? 0 : 1);
	} while (0);
}

// }}}

// {{{ FUNCTION regex_substr RETURNS STRING
struct regex_substr_t {
  char * _resultbuf;
  unsigned long _resultbuf_len;
  my_regex_t expr;
  int dynamic;
};

/* regex_substr init function */
my_bool regex_substr_init(UDF_INIT *initid, UDF_ARGS *args, char *message)
{
	DBUG_ENTER("regex::regex_substr_init");
	struct regex_substr_t *data = (struct regex_substr_t *)calloc(sizeof(struct regex_substr_t), 1);

	char *text = NULL;
	long long text_len = 0;
	char *pattern = NULL;
	long long pattern_len = 0;

	text = (char *)args->args[0];
	text_len = args->lengths[0];
	pattern = (char *)args->args[1];
	pattern_len = args->lengths[1];
	if (!data) {
		strcpy(message, "out of memory in regex_substr()");
		DBUG_RETURN(1);
	}

	data->_resultbuf = NULL;
	data->_resultbuf_len = 0L;
	initid->ptr = (char *)data;

	initid->maybe_null = 1;
	initid->max_length = 255;

	if (args->arg_count != 2) {
		strcpy(message,"wrong number of parameters for regex_substr()");
		DBUG_RETURN(1);
	}
	args->arg_type[0] = STRING_RESULT;
	args->arg_type[1] = STRING_RESULT;

	do {
		if (pattern) {
				// static regex pattern -> we can compile it once and reuse it 
				int stat;
				char *copy;
		
				// we have to make sure we have a NUL terminated C string
				// as argument for my_regcomp           
				copy = strndup(pattern, pattern_len);
				stat  = my_regcomp(&data->expr, copy, REG_EXTENDED, &my_charset_bin);
				free(copy);
		
				if (stat) {
					sprintf(message, "regcomp failed (error: %d)", stat);
					return 1; 
				}
		
				data->dynamic = 0;
			} else {
				data->dynamic = 1;
			}
	} while (0);

	DBUG_RETURN(0);
}

/* regex_substr deinit function */
void regex_substr_deinit(UDF_INIT *initid)
{
	DBUG_ENTER("regex::regex_substr_deinit");
	struct regex_substr_t *data = (struct regex_substr_t *)(initid->ptr);

	if (!data->dynamic) {
			// free static compiler pattern
			my_regfree(&data->expr);
		}

	if (initid->ptr) {
		free(initid->ptr);
	}
	DBUG_VOID_RETURN;
}

/* regex_substr actual processing function */
char * regex_substr(UDF_INIT *initid, UDF_ARGS *args, char *result, unsigned long *length, char *is_null, char *error)
{
	DBUG_ENTER("regex::regex_substr");
	struct regex_substr_t *data = (struct regex_substr_t *)initid->ptr;

	char *text = NULL;
	long long text_len = 0;
	char *pattern = NULL;
	long long pattern_len = 0;

	text = (char *)args->args[0];
	text_len = args->lengths[0];
	pattern = (char *)args->args[1];
	pattern_len = args->lengths[1];
	do {
		my_regmatch_t match;
			int stat;
			char *copy;
			
			if (data->dynamic) {
				copy = strndup(pattern, pattern_len);
				stat  = my_regcomp(&data->expr, copy, REG_EXTENDED, &my_charset_bin);
				free(copy);
				if (stat) {
					// TODO: need ERROR() and WARNING() macro
					RETURN_NULL;
				}
			}
		
			copy = strndup(text, text_len);
			stat = my_regexec(&data->expr, text, 1, &match, 0);
			free(copy);
		
			if (data->dynamic) {
				my_regfree(&data->expr);
			}
		
			if (stat) {
				if (stat != REG_NOMATCH) {
					fprintf(stderr, "regexec error %d '%s' '%s'\n", stat, pattern, text);
				}
				RETURN_NULL;
			}
		
			RETURN_STRINGL(text + match.rm_so, match.rm_eo - match.rm_so);
	} while (0);
}

// }}}

// {{{ FUNCTION regex_instr RETURNS INTEGER
struct regex_instr_t {
  my_regex_t expr;
  int dynamic;
};

/* regex_instr init function */
my_bool regex_instr_init(UDF_INIT *initid, UDF_ARGS *args, char *message)
{
	DBUG_ENTER("regex::regex_instr_init");
	struct regex_instr_t *data = (struct regex_instr_t *)calloc(sizeof(struct regex_instr_t), 1);

	char *text = NULL;
	long long text_len = 0;
	char *pattern = NULL;
	long long pattern_len = 0;

	text = (char *)args->args[0];
	text_len = args->lengths[0];
	pattern = (char *)args->args[1];
	pattern_len = args->lengths[1];
	if (!data) {
		strcpy(message, "out of memory in regex_instr()");
		DBUG_RETURN(1);
	}

	initid->ptr = (char *)data;

	initid->maybe_null = 1;

	if (args->arg_count != 2) {
		strcpy(message,"wrong number of parameters for regex_instr()");
		DBUG_RETURN(1);
	}
	args->arg_type[0] = STRING_RESULT;
	args->arg_type[1] = STRING_RESULT;

	do {
		if (pattern) {
				// static regex pattern -> we can compile it once and reuse it 
				int stat;
				char *copy;
		
				// we have to make sure we have a NUL terminated C string
				// as argument for my_regcomp           
				copy = strndup(pattern, pattern_len);
				stat  = my_regcomp(&data->expr, copy, REG_EXTENDED, &my_charset_bin);
				free(copy);
		
				if (stat) {
					sprintf(message, "regcomp failed (error: %d)", stat);
					return 1; 
				}
		
				data->dynamic = 0;
			} else {
				data->dynamic = 1;
			}
	} while (0);

	DBUG_RETURN(0);
}

/* regex_instr deinit function */
void regex_instr_deinit(UDF_INIT *initid)
{
	DBUG_ENTER("regex::regex_instr_deinit");
	struct regex_instr_t *data = (struct regex_instr_t *)(initid->ptr);

	if (!data->dynamic) {
			// free static compiler pattern
			my_regfree(&data->expr);
		}

	if (initid->ptr) {
		free(initid->ptr);
	}
	DBUG_VOID_RETURN;
}

/* regex_instr actual processing function */
long long regex_instr(UDF_INIT *initid, UDF_ARGS *args, char *is_null, char *error)
{
	DBUG_ENTER("regex::regex_instr");
	struct regex_instr_t *data = (struct regex_instr_t *)initid->ptr;

	char *text = NULL;
	long long text_len = 0;
	char *pattern = NULL;
	long long pattern_len = 0;

	text = (char *)args->args[0];
	text_len = args->lengths[0];
	pattern = (char *)args->args[1];
	pattern_len = args->lengths[1];
	do {
		my_regmatch_t match;
			int stat;
			char *copy;
			
			if (data->dynamic) {
				copy = strndup(pattern, pattern_len);
				stat  = my_regcomp(&data->expr, copy, REG_EXTENDED, &my_charset_bin);
				free(copy);
				if (stat) {
					// TODO: need ERROR() and WARNING() macro
					RETURN_NULL;
				}
			}
		
			copy = strndup(text, text_len);
			stat = my_regexec(&data->expr, text, 1, &match, 0);
			free(copy);
		
			if (data->dynamic) {
				my_regfree(&data->expr);
			}
		
			if (stat) {
				fprintf(stderr, "regexec error %d '%s' '%s'\n", stat, pattern, text);
				RETURN_NULL;
			}
		
			RETURN_LONGLONG(match.rm_so);
	} while (0);
}

// }}}

// {{{ FUNCTION regex_replace RETURNS STRING
struct regex_replace_t {
  char * _resultbuf;
  unsigned long _resultbuf_len;
};

/* regex_replace init function */
my_bool regex_replace_init(UDF_INIT *initid, UDF_ARGS *args, char *message)
{
	DBUG_ENTER("regex::regex_replace_init");
	struct regex_replace_t *data = (struct regex_replace_t *)calloc(sizeof(struct regex_replace_t), 1);

	char *text = NULL;
	long long text_len = 0;
	char *pattern = NULL;
	long long pattern_len = 0;
	char *replace = NULL;
	long long replace_len = 0;

	text = (char *)args->args[0];
	text_len = args->lengths[0];
	pattern = (char *)args->args[1];
	pattern_len = args->lengths[1];
	replace = (char *)args->args[2];
	replace_len = args->lengths[2];
	if (!data) {
		strcpy(message, "out of memory in regex_replace()");
		DBUG_RETURN(1);
	}

	data->_resultbuf = NULL;
	data->_resultbuf_len = 0L;
	initid->ptr = (char *)data;

	initid->maybe_null = 1;
	initid->max_length = 255;

	if (args->arg_count != 3) {
		strcpy(message,"wrong number of parameters for regex_replace()");
		DBUG_RETURN(1);
	}
	args->arg_type[0] = STRING_RESULT;
	args->arg_type[1] = STRING_RESULT;
	args->arg_type[2] = STRING_RESULT;

	DBUG_RETURN(0);
}

/* regex_replace deinit function */
void regex_replace_deinit(UDF_INIT *initid)
{
	DBUG_ENTER("regex::regex_replace_deinit");
	struct regex_replace_t *data = (struct regex_replace_t *)(initid->ptr);

	if (initid->ptr) {
		free(initid->ptr);
	}
	DBUG_VOID_RETURN;
}

/* regex_replace actual processing function */
char * regex_replace(UDF_INIT *initid, UDF_ARGS *args, char *result, unsigned long *length, char *is_null, char *error)
{
	DBUG_ENTER("regex::regex_replace");
	struct regex_replace_t *data = (struct regex_replace_t *)initid->ptr;

	char *text = NULL;
	long long text_len = 0;
	char *pattern = NULL;
	long long pattern_len = 0;
	char *replace = NULL;
	long long replace_len = 0;

	text = (char *)args->args[0];
	text_len = args->lengths[0];
	pattern = (char *)args->args[1];
	pattern_len = args->lengths[1];
	replace = (char *)args->args[2];
	replace_len = args->lengths[2];
	do {
		char *c_pattern, *c_replace, *c_text;
		char *result;

		c_pattern = strndup(pattern, pattern_len);
		c_replace = strndup(replace, replace_len);
		c_text    = strndup(text,    text_len);

		result = my_regex_replace(c_pattern, c_replace, c_text);

		free(c_pattern);
		free(c_replace);
		free(c_text);

		if (result) {
		  RETURN_STRING(result);
		} else {
		  RETURN_NULL;
		}
	} while (0);
}

// }}}

// }}}

#else
#error your installation does not support loading UDFs
#endif /* HAVE_DLOPEN */
